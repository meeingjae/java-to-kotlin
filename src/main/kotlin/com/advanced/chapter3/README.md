## Tips

* 공변성
  * chapter2에서 질문에 대한 해답을 주자
  * `Fish` <-- `GoldFish` 를 `List<Fish>` <-- `List<GoldFish>` 에도 적용하고 싶다면
    * `out` 키워드를 사용하면 된다
      * ex) `Cage<out T>`
        * `Cage<Fish>().putAll(Cage<GoldFish>())` 이 가능해진다
      * 하지만, `T` 클래스 내부에서 `other:Cage<out T>` 클래스는 `생산자` (other.get) 밖에 할 수 없다
        * 이유는 `T` 클래스 내부에는 `out`에 해당하는 다양한 타입이 있을 수 있는데
          * A 타입의 데이터를 other(B) 타입의 컬렉션에 집어 넣을 수 없기 때문이다
          * 한 마디로 타입 안정성이 깨진다
        * 따라서 `T` 클래스 펑션 내부에는 `other` 컬렉션의 데이터를 `꺼낼수만` 있다
* 반공변성(contra-variant)
  * `in` 키워드로 명시 가능
    * ex) `Cage<in T>`
    * `in` 키워드로 명시 된 파라미터 데이터는 `소비자`의 역할만 할 수 있다.
      * 즉 데이터를 넣을 수만 있다
      * 꺼내기 불가 !
        * 그 이유는 내가(T) 부모 타입의 파라미터를 받을 껀데, 부모타입의 데이터를 함부로 꺼내면, 난 GoldFish인데 부모 파라미터에서 꺼낸 타입이 RedFish일 수 있기 때문이다
          * 이럴 경우 에러 !
* **파라미터의 입장에서**
  * `out`
    * 생산자
    * 공변
    * 꺼내기만 할 수 있다
  * `in`
    * 소비자
    * 반공변
    * 넣기만 할 수 있다
  * 이는 함수 파라미터에 한에서만 공/반공변 상태를 정의할 수 있다
  * 기본적으로 Code 상에서는 `무공변` 상태이다
    * ex) val a:List<Fish> = List<GoldFish>() --> 에러
