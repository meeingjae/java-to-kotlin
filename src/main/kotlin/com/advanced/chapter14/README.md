## Tips

* 고차 함수
  * ex) `fun oper(): (Int,Int) -> Int {}`
    * Int 파라미터 두가지를 받아서 Int를 뱉는 함수를 정의할 수 있다
* 확장 함수의 타입
  * ex) `fun Int.add(other:Long): Int = this + other.toInt()`
    * 확장 함수에서 `this` 키워드는 확장 함수 타입의 객체를 의미한다 (수신객체)
      * 위 예시에서 `this`는 `Int`를 나타낸다
* 함수 리터럴 호출
  * 선언 된 `고차 함수` 및 `확장 함수` 는 모두 함수 리터럴로 호출이 가능하다
    * `invoke` 키워드를 명시할 수 있다
      * ex) `add(5,3L)` or `add.invoke(5,3L)` or `5.add(3L)` 모두 같은 내용
* 우리가 함수 리터럴을 정의하고, 사용할 때, 컴파일 시점에서 함수가 어떻게 변하는가?
  * 정답 : FunctionN 타입으로 변환된다
    * 코틀린은 함수를 일급 시민으로 다루기 때문
* 고차함수 사용 결로
  * 고차 함수를 사용하게 되면 FunctionN 이라는 객체로 변환되기 떄문에, 오버헤드가 발생할 수 있다
  * 함수에서 변수를 포획해서 사용할 경우(클로저) Ref 라는 변수로 감싸서 사용하기에 오버헤드가 발생할 수 있다
  * 오버헤드를 없애려면??
    * 인라인 함수를 사용하자 ~



